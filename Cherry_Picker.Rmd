---
title: "RNAi Library reformat for secodnary screen"
author: "Gianluca Pegoraro"
date: "March, 06 2016"
output: html_document
---
## Aim

This script uses as input a .csv file containing the number and positions of "Positive" wells to be picked from an arbitrary number of 96-well source plates. This table is then rearranged to produce a .csv file containing the well positions for a matched number of 96-well destination plates. The script allows for 2 output formats: `default`- which included the whole 96-wells on the destination plates -, or `internal` - which excludes all the edge wells on the plates. This behavior can be controlled by the `format` flag to be specified at the beginning of the script run. 

```{r loadAndClean}
library(plyr)
library(ggplot2)
library(data.table)
library(stringr)
library(knitr)
```

```{r, include=FALSE, warning=FALSE}
opts_chunk$set(
    fig.path = "output/",
    cache = TRUE,
    dev = c("png"),
    message = FALSE,
    warning = FALSE
    )
    theme_set(theme_minimal())
```

## Read the Columbus results
Set RegEx patterns for directory searches for Qiagen layout information at the well level data.

```{r regexFilename, results='hide'}
pat.w <- ".txt$" # Pattern for well data files
```

Create a list of the RegEx patterns set in the previous chunk. **Important:** the list names will be carried over all the next steps!!!

* w = well level data

```{r patList, results = 'hide'}
pat.list <- list(w= pat.w)
```

Recursively search the `input` directory and its subdirectories for files whose name includes the RegEx patterns defined two chunks above. The `path.list` functon outputs absolute file names. `path.list` is a list containing all the filenames on a per cell-level.

```{r directorySearch, results='hide'}
list.files <- function(x){
  dir(path = 'input', pattern = x, full.names = TRUE, recursive = TRUE, include.dirs = TRUE)
}

path.list <- llply(pat.list, list.files) 
```

Extract file names from absolut path and set them as list element names. 

```{r trimNames, results='hide'}
trim.names <- function(x){
  names(x) <- basename(x) # This assigns the filename to the file that it is read
  y <- x ## This is necessary because of scoping issues
}

path.list <- llply(path.list, trim.names) 
```

Recursively read and merge object level data files as data.frames. Rows are labeled with relative filenames (The `.id` variable). This and the previous chunks are slightly modified tricks adopted from H. Wickam ["Tidy Data" paper](http://vita.had.co.nz/papers/tidy-data.pdf).

```{r readMerge, results='hide'}
read.merge <- function(x){
  dt <-as.data.table(ldply(x, fread, sep = "\t")) 
}

dt.list <- llply(path.list, read.merge)
```

Separate the well level data.

```{r deleteDtList, results='asis'}
dt.qiagen <- dt.list$w

rm(dt.list)
```

The `dt.qiagen` data.table variables need to be renamed to:

* `source_rack`: The barcode (name) of the source plate | Required 
* `source_name`: A name for the source plate | Optional
* `source_description`: A description for the source plate | Optional
* `source_pos`: A numerical identifier for the well position | Required (**Do not edit**)
* `source_row`: A numerical identifier for the well row | Required (**Do not edit**)
* `source_col`: A numerical identifier for the well column | Required (**Do not edit**)
* `entrez_id`: A numerical identifier for the targeted gene | Optional (**Do not edit**)
* `user`: A flag indicating whether the well should be transferred or not| Required (**Can assume only the `Andria` or `Pedja` values)

```{r}
setnames(dt.qiagen, c("Plate Id", 
                      "Plate Name", 
                      "Plate Description", 
                      "Row", 
                      "Col", 
                      "Entrez Gene Id", 
                      "TAG"),
                     c("source_rack",
                       "source_name",
                       "source_description",
                       "source_row",
                       "source_col",
                       "entrez_id",
                       "user"))
```

We need to add these columns:

* `source_pos`: A numerical identifier for the well position | Required (**Do not edit**)
* `source_well`: A string name for the well position | Required (**Do not edit**)

```{r}
dt.qiagen <- dt.qiagen[order(source_rack, source_col, source_row)]

dt.qiagen[, source_well := paste0(source_row, source_col)]

dt.qiagen[, source_row := NULL]
```

## Generate a key to translate well name to numerical well position.

```{r}
pos_key <-
    data.table(source_pos = 1:96,
               source_col = rep(1:12, each = 8),
               source_row = rep(LETTERS[1:8], 12)
    )

pos_key[, source_well := paste0(source_row, source_col)]
```

Merge Key table with numerical positions to 
```{r}
setkey(pos_key, source_well)
setkey(dt.qiagen, source_well)

dt.source <- dt.qiagen[pos_key, nomatch = 0][order(source_rack, source_pos)]
```


Plot the Source plates layout
```{r, fig.height=12, fig.width= 18}
input_plot <- ggplot(dt.qiagen, aes(x = source_col, y = source_row, label = user))
input_plot + geom_text(size = 1.5) +
            facet_wrap( ~ source_rack) +
            scale_x_continuous(lim = c(1, 12), breaks = 1:12) +
            scale_y_reverse(lim = c(8, 1), breaks = 1:8, labels = LETTERS[1:8]) +
            ggtitle("Source Plates Layout")
```

Filter out empty wells to generate the output table. Also count how many source plates are actually present. 
```{r}
output <- input[source_flag == "Hit",]

n_source <- length(output[,unique(source_rack)])
```

Assign the destination positions. Only the internal 60 wells (Excluding rows A/H and columns 1/12) are used. 
```{r}
try(if(!(flag %in% c("default", "internal"))) stop("Invalid format flag, set it either to 'default' or 'internal'", call. = FALSE))

if(flag == "default"){
    output[, `:=`(dest_rack = rep(paste0("Output_Rack_", 1:n_source), each = 96),
                 dest_pos = 1:96,
                 dest_col = rep(1:12, each = 8),
                 dest_row = rep(1:8, 12))]
    
    output[, `:=`(dest_well = paste0(LETTERS[dest_row], dest_col))]
} 

if(flag == "internal") {
    output[, `:=`(dest_rack = rep(paste0("Output_Rack_", 1:(n_source*10)), each = 60),
                 dest_pos = as.vector(outer((10:15), seq(0, 72, 8), FUN = "+")),
                 dest_col = rep(2:11, each = 6),
                 dest_row = rep(2:7, 10))]
    
    output[, `:=`(dest_well = paste0(LETTERS[dest_row], dest_col))]
}
```

Plot the Source plates layout
```{r}
output_plot <- ggplot(output, aes(x = dest_col, y = dest_row, label = source_id))
output_plot + geom_text(size = 1.5) +
            facet_wrap( ~ dest_rack) +
            scale_x_continuous(lim = c(1, 12), breaks = 1:12) +
            scale_y_reverse(lim = c(8, 1), breaks = 1:8, labels = LETTERS[1:8]) +
            ggtitle("Dest Plates Layout")
```

```{r}
write.csv(x = output, 
          file = "output/Cherry_Pick_Worklist.csv", 
          quote = FALSE, 
          col.names = TRUE,
          row.names = FALSE)
```
Document the information about the analysis session
```{r sessionInfo, include=TRUE, echo=TRUE, results='markup'}
sessionInfo()
```