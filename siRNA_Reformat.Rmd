---
title: "RNAi Library reformat for secodnary screen"
author: "Gianluca Pegoraro"
date: "March, 08 2016"
output: html_document
---
## Aim

To reformat siRNA validation libraries for Andria and Pedja. The validation library was ordered from Qiagen and it arrived spread over 6 96-well plates. The siRNA's belong either to Andria or Pedja. The goal is to cheery pick user-specific siRNA from the 96-well source plates and reformat them in 1 384 destination plate per user. 

```{r loadAndClean}
library(plyr)
library(ggplot2)
library(data.table)
library(stringr)
library(knitr)
library(ggthemes)
```

```{r, include=FALSE, warning=FALSE}
opts_chunk$set(
    fig.path = "output/",
    cache = FALSE,
    dev = c("png"),
    message = FALSE,
    warning = FALSE
    )
    theme_set(theme_minimal())
```

## Read the Columbus results
Set RegEx patterns for directory searches for Qiagen layout information at the well level data.

```{r regexFilename, results='hide'}
pat.w <- ".txt$" # Pattern for well data files
```

Create a list of the RegEx patterns set in the previous chunk. **Important:** the list names will be carried over all the next steps!!!

* w = well level data

```{r patList, results = 'hide'}
pat.list <- list(w= pat.w)
```

Recursively search the `input` directory and its subdirectories for files whose name includes the RegEx patterns defined two chunks above. The `path.list` functon outputs absolute file names. `path.list` is a list containing all the filenames on a per cell-level.

```{r directorySearch, results='hide'}
list.files <- function(x){
  dir(path = 'input', pattern = x, full.names = TRUE, recursive = TRUE, include.dirs = TRUE)
}

path.list <- llply(pat.list, list.files) 
```

Extract file names from absolut path and set them as list element names. 

```{r trimNames, results='hide'}
trim.names <- function(x){
  names(x) <- basename(x) # This assigns the filename to the file that it is read
  y <- x ## This is necessary because of scoping issues
}

path.list <- llply(path.list, trim.names) 
```

Recursively read and merge object level data files as data.frames. Rows are labeled with relative filenames (The `.id` variable). This and the previous chunks are slightly modified tricks adopted from H. Wickam ["Tidy Data" paper](http://vita.had.co.nz/papers/tidy-data.pdf).

```{r readMerge, results='hide'}
read.merge <- function(x){
  dt <-as.data.table(ldply(x, fread, sep = "\t")) 
}

dt.list <- llply(path.list, read.merge)
```

Separate the well level data.

```{r deleteDtList, results='asis'}
dt_qiagen <- dt.list$w

rm(dt.list)
```

The `dt_qiagen` data.table variables need to be renamed to:

* `source_rack`: The barcode (name) of the source plate | Required 
* `source_name`: A name for the source plate | Optional
* `source_description`: A description for the source plate | Optional
* `source_pos`: A numerical identifier for the well position | Required (**Do not edit**)
* `source_row`: A numerical identifier for the well row | Required (**Do not edit**)
* `source_col`: A numerical identifier for the well column | Required (**Do not edit**)
* `entrez_id`: A numerical identifier for the targeted gene | Optional (**Do not edit**)
* `gene_symbol`: A character identifier for the targeted gene | Optional (**Do not edit**)
* `gene_description`: A character identifier for the targeted gene | Optional (**Do not edit**)
* `user`: A flag indicating whether the well should be transferred or not| Required (**Can assume only the `Andria` or `Pedja` values)

```{r}
setnames(dt_qiagen, c("Plate Id", 
                      "Plate Name", 
                      "Plate Description", 
                      "Row", 
                      "Col", 
                      "Entrez Gene Id",
                      "NCBI gene symbol",
                      "Gene Description",
                      "TAG"),
                     c("source_rack",
                       "source_name",
                       "source_description",
                       "source_row",
                       "source_col",
                       "entrez_id",
                       "gene_symbol",
                       "gene_description",
                       "user"))
```

We need to add these columns:

* `source_pos`: A numerical identifier for the well position | Required (**Do not edit**)
* `source_well`: A string name for the well position | Required (**Do not edit**)

```{r}
dt_qiagen <- dt_qiagen[order(source_rack, source_col, source_row)]

dt_qiagen[,  `:=` (source_well = paste0(source_row, source_col),
                   gene_description = str_replace_all(gene_description, ", ", "_"))]

dt_qiagen[, `:=`(source_row =  NULL,
                 source_col = NULL)]
```

Generate a key to translate well name to numerical well position.

```{r}
pos_key <-
    data.table(source_pos = 1:96,
               source_col = rep(1:12, each = 8),
               source_row = rep(1:8, 12),
               source_row2 = rep(LETTERS[1:8], 12)
    )

pos_key[, source_well := paste0(source_row2, source_col)]
```

Merge Key table with numerical positions to 
```{r}
setkey(pos_key, source_well)
setkey(dt_qiagen, source_well)

dt_source <- dt_qiagen[pos_key, nomatch = 0][order(source_rack, source_pos)]
```

Plot the Source plates layout
```{r, fig.height=12, fig.width= 18}
input_plot <- ggplot(dt_source, aes(x = source_col, y = source_row, label = gene_symbol, color = user))
input_plot + geom_text(size = 1.5) +
            facet_wrap( ~ source_rack) +
            scale_x_continuous(lim = c(1, 12), breaks = 1:12) +
            scale_y_reverse(lim = c(8, 1), breaks = 1:8, labels = LETTERS[1:8]) +
            scale_color_solarized("blue") +
            ggtitle("Source Plates Layout")
```

Filter out empty wells to generate the output table. Also count how many source plates are actually present. 
```{r}
dt_output_a <- dt_source[user == "Andria",]
dt_output_p <- dt_source[user == "Pedja",]
```

Write a function to map 96 to 384 well plates by interleaving dispenses (A1, C1, etc...; B1, D1, etc...).
```{r}
generator <- function(x) {
    dest_pos_final <- NULL
    for(i in seq(1,384,16)) 
        {dest_pos_temp <- c(seq(i, i+15, 2), seq(i+1, i+16, 2))
         dest_pos_final <- c(dest_pos_final, dest_pos_temp)}
    return(dest_pos_final)
}
```

Assign the destination positions. Only the internal 60 wells (Excluding rows A/H and columns 1/12) are used. 
```{r}
dt_output_a[, `:=`(dest_rack = rep("Andria_dest", each = 384),
                   dest_pos = generator(),
                   dest_col = rep(3:24, each = 16), #Start column 
                   dest_row = c(seq(1, 15, 2), seq(2, 16, 2)))]

dt_output_a[, `:=`(dest_well = paste0(LETTERS[dest_row], dest_col))]

dt_output_p[, `:=`(dest_rack = rep("Andria_dest", each = 384),
                   dest_pos = generator(),
                   dest_col = rep(3:24, each = 16), #Start column 
                   dest_row = c(seq(1, 15, 2), seq(2, 16, 2)))]

dt_output_p[, `:=`(dest_well = paste0(LETTERS[dest_row], dest_col))]
```

Plot the Dest plates layout
```{r andriaLayout}
output_plot_a <- ggplot(dt_output_a, aes(x = dest_col, y = dest_row, label = gene_symbol))
output_plot_a + geom_text(size = 1.5) +
            scale_x_continuous(lim = c(1, 24), breaks = 1:24) +
            scale_y_reverse(lim = c(16, 1), breaks = 1:16, labels = LETTERS[1:16]) +
            ggtitle("Dest Plates Layout Andria")
```
```{r pedjaLayout}
output_plot_p <- ggplot(dt_output_p, aes(x = dest_col, y = dest_row, label = gene_symbol))
output_plot_p + geom_text(size = 1.5) +
            scale_x_continuous(lim = c(1, 24), breaks = 1:24) +
            scale_y_reverse(lim = c(16, 1), breaks = 1:16, labels = LETTERS[1:16]) +
            ggtitle("Dest Plates Layout Pedja")
```

```{r}
write.csv(x = dt_output_a, 
          file = "output/Cherry_Pick_Worklist_Andria.csv", 
          quote = FALSE, 
          col.names = TRUE,
          row.names = FALSE)

write.csv(x = dt_output_p, 
          file = "output/Cherry_Pick_Worklist_Pedja.csv", 
          quote = FALSE, 
          col.names = TRUE,
          row.names = FALSE)
```
Document the information about the analysis session
```{r sessionInfo, include=TRUE, echo=TRUE, results='markup'}
sessionInfo()
```